diff --git a/app/fork_test/fork_test.cc b/app/fork_test/fork_test.cc
new file mode 100644
index 0000000..870d0c3
--- /dev/null
+++ b/app/fork_test/fork_test.cc
@@ -0,0 +1,64 @@
+// Fork Test
+
+#include <memory.h>
+#include <process.h>
+
+using namespace EPOS;
+OStream cout;
+
+const unsigned CODE_SIZE = 10000;
+const unsigned DATA_SIZE = 100000;
+
+
+int print_mmu_translation()
+{
+    cout << "Printing Task MMU Information:" << endl;
+
+    Task * this_task = Task::self();
+    cout << "My address space's page directory is located at "
+         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
+
+    cout << "Printing Code MMU Information:" << endl;
+    CPU::Log_Addr current_task_code_init = this_task->code();
+    cout << MMU::Translation(current_task_code_init) << endl;
+
+    cout << "Printing Data MMU Information:" << endl;
+    CPU::Log_Addr current_task_data_init = this_task->data();
+    cout << MMU::Translation(current_task_data_init) << endl;
+
+    return 0;
+}
+
+int main()
+{    
+    cout << "Test task context switching at a Thread::dispatch()\n" << endl;
+
+    Task * current_task = Task::self();
+    cout << "Attaching code segment..." << endl;
+    unsigned int cs_size = current_task->code_segment()->size();
+    Segment * code_segment = new (SYSTEM) Segment(cs_size, Segment::Flags::SYS);
+    CPU::int_disable();
+    CPU::Log_Addr tmp_code = current_task->address_space()->attach(code_segment);
+    memcpy(tmp_code, current_task->code(), cs_size);
+    current_task->address_space()->detach(code_segment);
+    CPU::int_enable();
+
+    cout << "Attaching data segment..." << endl;
+    unsigned int ds_size = current_task->data_segment()->size();
+    Segment * data_segment = new (SYSTEM) Segment(ds_size, Segment::Flags::SYS);
+    CPU::int_disable();
+    CPU::Log_Addr tmp_data = current_task->address_space()->attach(data_segment);
+    memcpy(tmp_data, current_task->data(), ds_size);
+    current_task->address_space()->detach(data_segment);
+    CPU::int_enable();
+
+    print_mmu_translation();
+    
+    new (SYSTEM) Task(code_segment, data_segment, &print_mmu_translation);
+
+    Thread::self()->yield();
+
+    cout << "I'm done, bye!" << endl;
+
+    return 0;
+}
diff --git a/app/fork_test/fork_test_traits.h b/app/fork_test/fork_test_traits.h
new file mode 100644
index 0000000..457943e
--- /dev/null
+++ b/app/fork_test/fork_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/segment_test/makefile b/app/fork_test/makefile
similarity index 100%
rename from tests/segment_test/makefile
rename to app/fork_test/makefile
diff --git a/app/segment_test/makefile b/app/segment_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/segment_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/segment_test/segment_test.cc b/app/segment_test/segment_test.cc
similarity index 100%
rename from tests/segment_test/segment_test.cc
rename to app/segment_test/segment_test.cc
diff --git a/tests/segment_test/segment_test_traits.h b/app/segment_test/segment_test_traits.h
similarity index 95%
rename from tests/segment_test/segment_test_traits.h
rename to app/segment_test/segment_test_traits.h
index d1ca6d5..457943e 100644
--- a/tests/segment_test/segment_test_traits.h
+++ b/app/segment_test/segment_test_traits.h
@@ -9,10 +9,10 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV32;
-    static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
diff --git a/app/task_test/makefile b/app/task_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/task_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/task_test/task_test.cc b/app/task_test/task_test.cc
new file mode 100644
index 0000000..c7e03e1
--- /dev/null
+++ b/app/task_test/task_test.cc
@@ -0,0 +1,77 @@
+// EPOS Task Test Program
+
+#include <time.h>
+#include <process.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+int print_mmu_translation(Task * this_task)
+{
+    cout << "Printing Task MMU Information:" << endl;
+    
+    cout << "My address space's page directory is located at "
+         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
+         
+    cout << "Printing Code MMU Information:" << endl;
+    CPU::Log_Addr current_task_code_init = this_task->code();
+    cout << MMU::Translation(current_task_code_init) << endl;
+
+    cout << "Printing Data MMU Information:" << endl;
+    CPU::Log_Addr current_task_data_init = this_task->data();
+    cout << MMU::Translation(current_task_data_init) << endl;
+
+    return 0;
+}
+
+int func_task(void)
+{   
+    cout << "I'm the created task and I'll print my info" << endl;
+    print_mmu_translation(Task::self());
+    cout << "I will now suspend myself until I receive a Timer Interrupt" << endl;
+    Task::self()->main()->suspend();
+    cout << "I'm the created task and now I'll finish" << endl;
+    return 0;
+}
+
+int main()
+{
+    cout << "Test task context switching at a Timer Interrupt\n" << endl;
+    
+    cout << "This is my information:" << endl;
+    Task * current_task = Task::self();
+    print_mmu_translation(current_task);
+
+    cout << "I will now perform a manual fork and create another task with the same code and data segments..." << endl;
+
+    
+    unsigned int cs_size = current_task->code_segment()->size();
+    Segment * code_segment = new (SYSTEM) Segment(cs_size, Segment::Flags::SYS);
+    CPU::int_disable();
+    CPU::Log_Addr tmp_code = current_task->address_space()->attach(code_segment);
+    memcpy(tmp_code, current_task->code(), cs_size);
+    current_task->address_space()->detach(code_segment);
+    CPU::int_enable();
+    
+    unsigned int ds_size = current_task->data_segment()->size();
+    Segment * data_segment = new (SYSTEM) Segment(ds_size, Segment::Flags::SYS);
+    CPU::int_disable();
+    CPU::Log_Addr tmp_data = current_task->address_space()->attach(data_segment);
+    memcpy(tmp_data, current_task->data(), ds_size);
+    current_task->address_space()->detach(data_segment);
+    CPU::int_enable();
+    Task * new_task = new (SYSTEM) Task(code_segment, data_segment, &func_task);
+
+    cout << "I will now cause a timer interrupt!" << endl;
+    
+
+    cout << "I'll now yield so it can print its information" << endl;
+    
+    new_task->main()->resume();
+
+    cout << "All tasks done, bye!" << endl;
+
+    return 0;
+}
+
diff --git a/app/task_test/task_test_traits.h b/app/task_test/task_test_traits.h
new file mode 100644
index 0000000..73fd2ad
--- /dev/null
+++ b/app/task_test/task_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/armv7/armv7_cpu.h b/include/architecture/armv7/armv7_cpu.h
index 30211cd..0da34b0 100644
--- a/include/architecture/armv7/armv7_cpu.h
+++ b/include/architecture/armv7/armv7_cpu.h
@@ -348,11 +348,10 @@ public:
     }
 
     // TLB maintenance operations
-    static void invalidate_tlb() {
-        ASM("mov r0, #0x0               \t\n"
-            "mcr p15, 0, r0, c8, c7, 0  \t\n"
-        ); // TLBIALL - Invalidate entire Unifed TLB
-    }
+
+    static void invalidate_tlb() { ASM("mcr p15, 0, %0, c8, c7, 0" : : "r" (0)); }
+
+    static void invalidate_tlb(Reg r) { ASM("mcr p15, 0, %0, c8, c7, 0" : : "r" (r)); }
 
     static void invalidate_caches() {
         ASM("                  \t\n\
diff --git a/include/architecture/armv7/armv7_mmu.h b/include/architecture/armv7/armv7_mmu.h
index 74191d7..9bbb9a5 100644
--- a/include/architecture/armv7/armv7_mmu.h
+++ b/include/architecture/armv7/armv7_mmu.h
@@ -11,6 +11,7 @@ __BEGIN_SYS
 class ARMv7_MMU: public MMU_Common<12, 8, 12>
 {
     friend class CPU;
+    friend class Setup;
 
 private:
     typedef Grouping_List<Frame> List;
@@ -20,6 +21,7 @@ private:
     static const unsigned int RAM_BASE = Memory_Map::RAM_BASE;
     static const unsigned int APP_LOW = Memory_Map::APP_LOW;
     static const unsigned int PHY_MEM = Memory_Map::PHY_MEM;
+    static const unsigned int SYS = Memory_Map::SYS;
 
 public:
     // Page Flags
@@ -88,7 +90,8 @@ public:
     };
 
     // Page_Table
-    class Page_Table  {
+    class Page_Table
+    {
     public:
         Page_Table() {}
 
@@ -145,7 +148,62 @@ public:
     };
 
     // Page Directory
-    typedef Page_Table Page_Directory;
+    class Page_Directory 
+    {
+    public:
+        Page_Directory() {}
+
+        PD_Entry & operator[](unsigned int i) { return _entry[i]; }
+        Page_Directory & log() { return *static_cast<Page_Directory *>(phy2log(this)); }
+
+        void map(int from, int to, Page_Flags flags, Color color) {
+            Phy_Addr * addr = alloc(to - from, color);
+            if(addr)
+                remap(addr, from, to, flags);
+            else
+                for( ; from < to; from++) {
+                    Log_Addr * pte = phy2log(&_entry[from]);
+                    *pte = phy2pte(alloc(1, color), flags);
+                }
+        }
+
+        void map_contiguous(int from, int to, Page_Flags flags, Color color) {
+            remap(alloc(to - from, color), from, to, flags);
+        }
+
+        void remap(Phy_Addr addr, int from, int to, Page_Flags flags) {
+            addr = align_page(addr);
+            for( ; from < to; from++) {
+                Log_Addr * pte = phy2log(&_entry[from]);
+                *pte = phy2pte(addr, flags);
+                addr += sizeof(Page);
+            }
+        }
+
+        void unmap(int from, int to) {
+            for( ; from < to; from++) {
+                free(_entry[from]);
+                Log_Addr * pte = phy2log(&_entry[from]);
+                *pte = 0;
+            }
+        }
+
+        friend OStream & operator<<(OStream & os, Page_Directory & pt) {
+            os << "{\n";
+            int brk = 0;
+            for(unsigned int i = 0; i < PD_ENTRIES; i++)
+                if(pt[i]) {
+                    os << "[" << i << "]=" << pt[i] << "  ";
+                    if(!(++brk % 4))
+                        os << "\n";
+                }
+            os << "\n}";
+            return os;
+        }
+
+    private:
+        PD_Entry _entry[PD_ENTRIES]; // the Phy_Addr in each entry passed through phy2pte()
+    };
 
     // Chunk (for Segment)
     class Chunk
@@ -225,22 +283,34 @@ public:
     // Directory (for Address_Space)
     class Directory
     {
+        friend class Task;
+
     public:
-        Directory() : _pd(reinterpret_cast<Page_Directory *>((calloc(4, WHITE) & ~(0x3fff)))), _free(true) { // each pd has up to 4096 entries and must be aligned with 16KB
-            for(unsigned int i = directory(PHY_MEM); i < PD_ENTRIES; i++)
+        Directory() : _base(calloc(7, WHITE)), _free(true) {
+            // each pd has up to 4096 entries and must be aligned with 16K
+            if (_base & 0x3FFF) {
+                _base = (_base & ~(0x3FFF)) + (0x1 << 14);
+            }
+
+            _pd = Phy_Addr(_base);
+            Page_Directory * _master = current();
+
+            for(unsigned int i = directory(PHY_MEM); i < directory(APP_LOW); i++)
+                (*_pd)[i] = (*_master)[i];
+            for(unsigned int i = directory(SYS); i < PD_ENTRIES; i++)
                 (*_pd)[i] = (*_master)[i];
         }
 
         Directory(Page_Directory * pd) : _pd(pd), _free(false) {}
 
-        ~Directory() { if(_free) free(_pd); }
+        ~Directory() { if(_free) free(_pd, sizeof(Page_Directory) / sizeof(Page)); }
 
         Phy_Addr pd() const { return _pd; }
 
-        void activate() const { CPU::pdp(pd()); }
+        void activate() const { ARMv7_MMU::pd(_pd); }
 
         Log_Addr attach(const Chunk & chunk, unsigned int from = directory(APP_LOW)) {
-            for(unsigned int i = from; i < PD_ENTRIES; i++)
+            for(unsigned int i = from; i < directory(SYS); i++)
                 if(attach(i, chunk.pt(), chunk.pts(), chunk.flags()))
                     return i << DIRECTORY_SHIFT;
             return Log_Addr(false);
@@ -290,12 +360,17 @@ public:
         }
 
         void detach(unsigned int from, const Page_Table * pt, unsigned int n) {
-            for(unsigned int i = from; i < from + n; i++)
+            for(unsigned int i = from; i < from + n; i++) {
                 _pd->log()[i] = 0;
+                flush_tlb(i << DIRECTORY_SHIFT);
+            }
+            CPU::isb();
+            CPU::dsb();
         }
 
     private:
         Page_Directory * _pd;  // this is a physical address, but operator*() returns a logical address
+        Phy_Addr _base;
         bool _free;
     };
 
@@ -408,7 +483,8 @@ public:
 
     static unsigned int allocable(Color color = WHITE) { return _free[color].head() ? _free[color].head()->size() : 0; }
 
-    static Page_Directory * volatile current() { return reinterpret_cast<Page_Directory * volatile>(CPU::pdp());}
+    static Page_Directory * volatile current() { return static_cast<Page_Directory * volatile>(pd());}
+
     static Phy_Addr physical(Log_Addr addr) {
         Page_Directory * pd = current();
         Page_Table * pt = pd->log()[directory(addr)];
@@ -420,9 +496,10 @@ public:
     static PD_Entry phy2pde(Phy_Addr frame) { return (frame) | Page_Flags::PD_FLAGS; }
     static Phy_Addr pde2phy(PD_Entry entry) { return (entry & ~Page_Flags::PD_MASK); }
 
-    static void flush_tlb() {} //TODO
-    static void flush_tlb(Log_Addr addr) {} //TODO
+    static void flush_tlb() { CPU::invalidate_tlb(); }
 
+    static void flush_tlb(Log_Addr addr) { CPU::invalidate_tlb(directory_bits(addr)); }
+  
     static Log_Addr phy2log(Phy_Addr phy) { return Log_Addr((RAM_BASE == PHY_MEM) ? phy : (RAM_BASE > PHY_MEM) ? phy - (RAM_BASE - PHY_MEM) : phy + (PHY_MEM - RAM_BASE)); }
     static Phy_Addr log2phy(Log_Addr log) { return Phy_Addr((RAM_BASE == PHY_MEM) ? log : (RAM_BASE > PHY_MEM) ? log + (RAM_BASE - PHY_MEM) : log - (PHY_MEM - RAM_BASE)); }
 
@@ -439,6 +516,9 @@ public:
     }
 
 private:
+    static Phy_Addr pd() { return CPU::ttbr0(); }
+    static void pd(Phy_Addr pd) { CPU::ttbr0(pd); CPU::invalidate_tlb(); CPU::isb(); CPU::dsb(); }
+
     static void init();
 
 private:
diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
index 1d9fc50..033067a 100644
--- a/include/architecture/mmu.h
+++ b/include/architecture/mmu.h
@@ -83,11 +83,14 @@ public:
 
     static Log_Addr align_page(const Log_Addr & addr) { return (addr + sizeof(Page) - 1) & ~(sizeof(Page) - 1); }
     static Log_Addr align_directory(const Log_Addr & addr) { return (addr + PT_ENTRIES * sizeof(Page) - 1) &  ~(PT_ENTRIES * sizeof(Page) - 1); }
+
+    static Log_Addr directory_bits(const Log_Addr & addr) { return (addr & ~((1 << DIRECTORY_BITS) - 1)); }
 };
 
 class No_MMU: public MMU_Common<0, 0, 0>
 {
     friend class CPU;
+    friend class Setup;
 
 private:
     typedef Grouping_List<unsigned int> List;
diff --git a/include/memory.h b/include/memory.h
index 63899b1..de38907 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -12,6 +12,7 @@ class Address_Space: private MMU::Directory
     friend class Init_System;   // for Address_Space(pd)
     friend class Thread;        // for Address_Space(pd)
     friend class Scratchpad;    // for Address_Space(pd)
+    friend class Task;
 
 private:
     using MMU::Directory::activate;
diff --git a/include/process.h b/include/process.h
index e7beb71..3dfea7c 100644
--- a/include/process.h
+++ b/include/process.h
@@ -3,6 +3,7 @@
 #ifndef __process_h
 #define __process_h
 
+#include <memory.h>
 #include <architecture.h>
 #include <machine.h>
 #include <utility/queue.h>
@@ -26,9 +27,11 @@ class Thread
 protected:
     static const bool preemptive = Traits<Thread>::Criterion::preemptive;
     static const bool reboot = Traits<System>::reboot;
+    static const bool multitask = Traits<System>::multitask;
 
     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
-    static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
+    static const unsigned int STACK_SIZE = Traits<System>::STACK_SIZE;
+    static const unsigned int USER_STACK_SIZE = Traits<Application>::STACK_SIZE;
 
     typedef CPU::Log_Addr Log_Addr;
     typedef CPU::Context Context;
@@ -58,12 +61,13 @@ public:
 
     // Thread Configuration
     struct Configuration {
-        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), criterion(c), stack_size(ss) {}
+        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE, Task * t = 0)
+        : state(s), criterion(c), stack_size(ss), task(t) {}
 
         State state;
         Criterion criterion;
         unsigned int stack_size;
+        Task * task;  // task to which the thread is related
     };
 
 
@@ -117,6 +121,10 @@ private:
     static void init();
 
 protected:
+    /* From EPOS dev, not sure what it does yet. */
+    Task * _task;
+    Segment * _user_stack;
+
     char * _stack;
     Context * volatile _context;
     volatile State _state;
@@ -129,24 +137,24 @@ protected:
     static Scheduler<Thread> _scheduler;
 };
 
-
-template<typename ... Tn>
-inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
-: _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
-{
-    constructor_prologue(STACK_SIZE);
-    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
-    constructor_epilogue(entry, STACK_SIZE);
-}
-
-template<typename ... Tn>
-inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
-{
-    constructor_prologue(conf.stack_size);
-    _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
-    constructor_epilogue(entry, conf.stack_size);
-}
+// @pedro: NOT USED
+// template<typename ... Tn>
+// inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
+// : _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
+// {
+//     constructor_prologue(STACK_SIZE);
+//     _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
+//     constructor_epilogue(entry, STACK_SIZE);
+// }
+
+// template<typename ... Tn>
+// inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+// : _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+// {
+//     constructor_prologue(conf.stack_size);
+//     _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
+//     constructor_epilogue(entry, conf.stack_size);
+// }
 
 
 // A Java-like Active Object
@@ -178,6 +186,139 @@ private:
     Thread * _handler;
 };
 
+// @pedro: Taken from EPOS dev branch, coloring removed
+class Task 
+{
+    friend class Thread;
+private:
+    static const bool multitask = Traits<System>::multitask;
+    typedef CPU::Log_Addr Log_Addr;
+    typedef CPU::Phy_Addr Phy_Addr;
+    typedef CPU::Context Context;
+    typedef Thread::Queue Queue;
+
+protected:
+    // This constructor is only used by Thread::init()
+    template<typename ... Tn>
+    Task(Address_Space * as, Segment * cs, Segment * ds, int (* entry)(Tn ...), const Log_Addr & code, const Log_Addr & data, Tn ... an)
+    : _as(as), _cs(cs), _ds(ds), _entry(entry), _code(code), _data(data) {
+        db<Task, Init>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+
+        _current = this;
+        activate();
+        _main = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN, 0, this), entry, an ...);
+    }
+
+public:
+    /* Creates Task and attach segments without Thread::Configuration */
+    template<typename ... Tn>
+    Task(Segment * cs, Segment * ds, int (* entry)(Tn ...), Tn ... an)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _entry(entry), _code(_as->attach(_cs)), _data(_as->attach(_ds)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+
+        _main = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::MAIN, 0, this), entry, an ...);
+    }
+
+    /* Creates Task and attach segments, data specified in Thread::Configuration */
+    template<typename ... Tn>
+    Task(const Thread::Configuration & conf, Segment * cs, Segment * ds, int (* entry)(Tn ...), Tn ... an)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _entry(entry), _code(_as->attach(_cs)), _data(_as->attach(_ds)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+
+        _main = new (SYSTEM) Thread(Thread::Configuration(conf.state, conf.criterion, 0, this), entry, an ...);
+    }
+
+    ~Task();
+
+    Address_Space * address_space() const { return _as; }
+
+    Segment * code_segment() const { return _cs; }
+    Segment * data_segment() const { return _ds; }
+
+    Log_Addr code() const { return _code; }
+    Log_Addr data() const { return _data; }
+
+    Thread * main() const { return _main; }
+
+    static Task * volatile self() { return current(); }
+
+private:
+
+    void activate() const { _as->activate(); }
+
+    void insert(Thread * t) { _threads.insert(new (SYSTEM) Queue::Element(t)); }
+    void remove(Thread * t) { Queue::Element * el = _threads.remove(t); if(el) delete el; }
+
+    /* For main Task */
+    static Task * volatile current() { return _current; }
+    static void current(Task * t) { _current = t; }
+
+    static void init();
+
+private:
+    Address_Space * _as;
+    Segment * _cs;
+    Segment * _ds;
+    Log_Addr _entry;
+    Log_Addr _code;
+    Log_Addr _data;
+    Thread * _main;
+    Queue _threads;
+
+    static Task * volatile _current;
+};
+
+// @pedro: Also taken from EPOS dev
+
+// Thread inline methods that depend on Task
+template<typename ... Tn>
+inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
+: _task(Task::self()), _user_stack(0), _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
+{
+    constructor_prologue(STACK_SIZE);
+    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
+    constructor_epilogue(entry, STACK_SIZE);
+}
+
+template<typename ... Tn>
+inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+: _task(conf.task ? conf.task : Task::self()), _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+{
+    if(multitask && !conf.stack_size) { // auto-expand, user-level stack
+        constructor_prologue(STACK_SIZE);
+        _user_stack = new (SYSTEM) Segment(USER_STACK_SIZE);
+
+        // Attach the thread's user-level stack to the current address space so we can initialize it
+        Log_Addr ustack = Task::self()->address_space()->attach(_user_stack);
+
+        // Initialize the thread's user-level stack and determine a relative stack pointer (usp) from the top of the stack
+        Log_Addr usp = ustack + USER_STACK_SIZE;
+        if(conf.criterion == MAIN)
+            usp -= CPU::init_user_stack(usp, 0, an ...); // the main thread of each task must return to crt0 to call _fini (global destructors) before calling __exit
+        else
+            usp -= CPU::init_user_stack(usp, &__exit, an ...); // __exit will cause a Page Fault that must be properly handled
+
+        // Detach the thread's user-level stack from the current address space
+        Task::self()->address_space()->detach(_user_stack, ustack);
+
+        // Attach the thread's user-level stack to its task's address space so it will be able to access it when it runs
+        ustack = _task->address_space()->attach(_user_stack);
+
+        // Determine an absolute stack pointer (usp) from the top of the thread's user-level stack considering the address it will see it when it runs
+        usp = ustack + USER_STACK_SIZE - usp;
+
+        // Initialize the thread's system-level stack
+        _context = CPU::init_stack(usp, _stack + STACK_SIZE, &__exit, entry, an ...);
+    } else { // single-task scenarios and idle thread, which is a kernel thread, don't have a user-level stack
+        constructor_prologue(conf.stack_size);
+        _user_stack = 0;
+        _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
+    }
+
+    constructor_epilogue(entry, STACK_SIZE);
+}
+
+ 
 __END_SYS
 
 #endif
diff --git a/src/api/task.cc b/src/api/task.cc
new file mode 100644
index 0000000..e8e47ab
--- /dev/null
+++ b/src/api/task.cc
@@ -0,0 +1,22 @@
+// EPOS Task Implementation
+
+#include <process.h>
+
+__BEGIN_SYS
+
+// Class attributes
+Task * volatile Task::_current;
+
+
+// Methods
+Task::~Task()
+{
+    db<Task>(TRC) << "~Task(this=" << this << ")" << endl;
+
+    while(!_threads.empty())
+        delete _threads.remove()->object();
+
+    delete _as;
+}
+
+__END_SYS
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 191597d..2a7b45c 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -38,6 +38,9 @@ void Thread::constructor_epilogue(Log_Addr entry, unsigned int stack_size)
 
     assert((_state != WAITING) && (_state != FINISHING)); // invalid states
 
+    if(multitask)
+        _task->insert(this);
+
     if((_state != READY) && (_state != RUNNING))
         _scheduler.suspend(this);
 
@@ -85,6 +88,10 @@ Thread::~Thread()
         break;
     }
 
+    if(multitask) {
+        _task->remove(this);
+        delete _user_stack;
+    }
     if(_joining)
         _joining->resume();
 
@@ -342,6 +349,11 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
         }
         db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
 
+        if(multitask && (next->_task != prev->_task)) {
+            next->_task->activate();
+            Task::current(next->_task);
+        }
+
         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
         // and necessary because of context switches, but here, we are locked() and
         // passing the volatile to switch_constext forces it to push prev onto the stack,
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index 53ade54..9268774 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -27,7 +27,30 @@ void Thread::init()
 
     Criterion::init();
 
-    new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
+    // @pedro: single-core u-kernel -- no need to check which CPU::id()
+    if(Traits<System>::multitask) {
+        /* Create Address Space and data segments, along with logical addresses for each */
+        Address_Space * as = new (SYSTEM) Address_Space(MMU::current());
+        Segment * cs = new (SYSTEM) Segment(Log_Addr(si->lm.app_code), si->lm.app_code_size, Segment::Flags::APPC);
+        Segment * ds = new (SYSTEM) Segment(Log_Addr(si->lm.app_data), si->lm.app_data_size, Segment::Flags::APPD);
+        Log_Addr code = si->lm.app_code;
+        Log_Addr data = si->lm.app_data;
+        /* Argument passing */ //@pedro: not functioning
+        // int argc = static_cast<int>(si->lm.app_extra_size);
+        // int * argv = static_cast<int *>(si->lm.app_extra);
+        // new (SYSTEM) Task(as, cs, ds, main, code, data, argc, argv);
+
+        new (SYSTEM) Task(as, cs, ds, main, code, data);
+        
+        if(si->lm.has_ext)
+            db<Init>(INF) << "Thread::init: additional data from mkbi at "  << reinterpret_cast<void *>(si->lm.app_extra) << ":" << si->lm.app_extra_size << endl;
+    
+    } else {
+        // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
+        // which will directly call main(). In this case, _init will already have been called,
+        // before Init_Application to construct MAIN's global objects.
+        new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(main));
+    } 
 
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
